// // modified from https://github.com/ndokmai/rust-sgx-remote-attestation/blob/4e8277293754b3c26d32ee76844749ef85bf96f9/ra-enclave/src/local_attestation.rs#L25

// use sgx_isa::crypto::mac::Cmac;
// use sgx_isa::{Keyname, Keyrequest, Report, Targetinfo};

// /// Fetches the own target info and puts it into a byte-vector.
// pub fn get_own_targetinfo() -> Vec<u8> {
//     let ti = Targetinfo::from(Report::for_self());
//     let result: &[u8] = ti.as_ref();
//     result.to_vec().clone()
// }

// /// Tries to create a report for the given target and puts it into a byte-vector.
// /// Returns None if the target is invalid, returns the report otherwise.
// pub fn locally_attest(target: &Vec<u8>, data: &[u8; 64]) -> Option<Vec<u8>> {
//     let ti = Targetinfo::try_copy_from(&target[..])?;
//     let report = Report::for_target(&ti, data);
//     let report: &[u8] = report.as_ref();
//     Some(report.to_vec().clone())
// }

// /// Verifies a report created by locally_attest (or any other report generated by an enclave).
// /// Returns true if the report is correctly formed and has been generated on the same machine/CPU
// /// as the current enclave.
// pub fn verify_local_attest(report: &[u8]) -> Result<(), LocalAttestationError> {
//     if report.len() != Report::UNPADDED_SIZE {
//         return Err(LocalAttestationError::IncorrectReportLength);
//     }
//     // Can unwrap since the length is verified
//     let report = Report::try_copy_from(report).unwrap();
//     verify_report(&report)
// }

// /// Verifies the given report locally, a.k.a. returns true if the Report was created in an enclave
// /// on the same CPU.
// pub fn verify_report(report: &Report) -> Result<(), LocalAttestationError> {
//     // Derive the report key.
//     let request = Keyrequest {
//         keyname: Keyname::Report as _,
//         keyid: report.keyid.clone(),
//         ..Default::default()
//     };
//     // Maybe result false instead of panicking, but the specs
//     // ( https://software.intel.com/en-us/articles/intel-sdm Volume 3C, Chapter 40-4 )
//     // state that EGETKEY should have a problem with this parameters, so if it doesn't work
//     // there might be a deeper issue making a panic appropriate.
//     let key = request.egetkey().expect("Can't derive report key");

//     // Extract the data that is signed.
//     let report_data: &[u8] = report.as_ref();
//     let mut mac_data = &report_data[0..Report::UNPADDED_SIZE - 48];

//     // Compute and verify the mac on the data.
//     let mut mac = Cmac::new(&key)?;
//     mac.verify(&mut mac_data, &report.mac)
//         .map_err(|_| LocalAttestationError::IntegrityError)
// }
